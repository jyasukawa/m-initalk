＜なぜsigaction＞
signal()関数は、現在のハンドラーの実行中に他のシグナルが到着するのを (必然的に) ブロックしません。sigaction()現在のハンドラーが戻るまで他のシグナルをブロックできます。

<プロセスとは>
プロセスとはシステム内で実行されているプログラムのことです。 システム内では常に複数のプログラムが稼働しています。ユーザーがコマンド実行することでプロセスは生成され、処理を終えると消滅します。
プロセスIDは値が一意に割り当てられているため、killコマンドで一度に複数のプロセスを対象とすることがません。killallコマンドでプロセス名を指定した場合は複数のプロセスを一度に終了することができます。

＜シグナルとは＞
シグナルは、割り込みによってプロセスに特定の動作をするように通知することができる仕組みです。例えばあるプロセスに対してkillコマンドなどを実行するとします。すると特定のシグナルがプロセスに対して送信されます。通知を受け取ったプロセスは処理の途中でもその処理を中止し消滅します。デフォルトでプロセスを終了させる場合は、システムからSIGTERMがプロセスに対して送信されます。

＜クリーンアップとは＞
通常の処理を終える場合やSIGTERMがプロセスに対して送信された場合、プロセスが終了する前にプロセス自身が終了処理を行います。終了するための処理を行うことをクリーンアップと言います。クリーンアップでは使っていたリソースの開放やロックファイルの削除などを行います。
しかし、SIGKILLなどで強制終了した場合は、カーネル側で強制的に終了させられるためクリーンアップは行われません。

＜シグナルハンドラーの実装＞
シグナルを扱うハンドラは、普通のプログラムと同様に記述できてしまいます。
ルール違反をしていても、コンパイラや静的解析ツールは指摘してくれません。
そのため、プログラマが「ルール」を意識してハンドラを記述する必要があります。
シグナルハンドラ関数には非常に注意しなければならない。 他の場所の処理はプログラム実行の任意の箇所で中断される可能性があるためである。 POSIX には「安全な関数 (safe function)」という概念がある。 シグナルが安全でない関数の実行を中断し、かつ handler が安全でない関数を呼び出した場合、プログラムの挙動は未定義である。
非同期シグナル安全な関数以外は使用するな」
です。これが、シグナルハンドラを記述する際のルールです。
「非同期シグナル安全」操作は、割り込まれている操作を妨げないことが保証されています。
たとえば、プログラムが printf(3S) を呼び出している最中にシグナルが発生し、そのシグナルを処理するハンドラ自体も printf() を呼び出すとします。その場合は、2 つの printf() 文の出力が混ざり合ってしまいます。これを避けるには、printf() がシグナルに割り込まれたときにシグナルハンドラが printf() を呼び出さないようにします。

ハンドラと操作の干渉を回避するには、そうした状況が決して発生しないようにするか (通常は危険領域でシグナルをマスクする)、シグナルハンドラ内部では「非同期シグナル安全」操作以外は使用しないようにします。
同じmanページに、async-signal-safeな関数一覧が記載されています。
これらの関数のみ、シグナルハンドラ内での動作が保証されており、使用が許されています。

シグナルが発生すると、プログラムの通常の制御フローは中断される。シグナルハンドラによって捕捉されているシグナルが発生した場合、そのハンドラが呼び出される。ハンドラが終了すると、シグナルが発生した時点からプログラムは続行する。この処理は、ライブラリ関数実行時にシグナルが発生し、シグナルハンドラが同じライブラリ関数を呼び出す場合、問題を引き起こす可能性がある。

三行でまとめると
* シグナルハンドラ内でprintf()してはいけない
* というより、余計な処理を書いてはいけない
* もう一度言う、シグナルハンドラで余計なことをするな、非常に大事なことだ
回避する方法
なにもしない
この記事をマジメに読もうとしている人をターゲットにあえて書くと、あなたの考えるシグナルハンドラに書きたい処理は、十中八九、不必要なことであったり「筋の悪い」ことであったりする。ただでさえ制約の多いシグナルハンドラであえて行うような処理ではない。
fdをcloseしたい
おそらくSIGTERMを受けてやろうと思っているのだろうが、やらなくてよい。プロセスが終了すると勝手に閉じてくれる。
メモリ領域をfreeしたい
おそらくSIGTERMを受けてやろうと思っているのだろうが、やらなくてよい。プロセスが終了すると勝手に開放してくれる。
tmpfileを消したい
おそらくSIGTERMを受けてやろうと思っているのだろうが、終了時にやるべきではない。起動時に消したり再初期化したりすればよい。
本当にやらないといけない処理なのかを今一度考えた上で「なにもしない」という選択肢を考慮すべきである。

<シグナルアクション関連の情報>
sa_flags	シグナルの使い方を示す SA_* フラグ7
sa_handler	SIG_IGN、SIG_DFL、シグナルハンドラへのポインタなど、シグナルアクションの種類
sa_mask	ハンドラ実行時にブロックする (受信を禁止する) シグナル

シグナルを使うには大きく分けて、signal関数とsigaction関数の2つの関数がある。
signal関数よりもsigaction関数のほうが、機能や移植性から見ても有用で、利用を推奨。

シグナルハンドラ	プロセスにシグナルを送信すると、そのプロセスの正常処理に割り込んで、シグナル固有の処理(シグナルハンドラ) が実行される。
PID	プロセスID（process ID。
プロセスIDとは、オペレーティング（OS）が現在実行中のプロセスを識別するために割り当てる識別子。WindowsやUNIX系OSなどで利用され、一般的には整数の通し番号。
シグナルマスク	「〇〇のシグナルハンドラの実行中は、××のシグナルは無視する」っていう時に便利な機能。
シグナルというのはイベントが起きるとプログラムの実行部分に関係なく割り込んで来るので、それを防ぐことができる。

＜sigaction関数とは＞
特定のシグナルを受信した際の プロセスの動作を変更するのに使用。

truct sigaction {
    void     (*sa_handler)(int);
    void     (*sa_sigaction)(int, siginfo_t *, void *);　
    sigset_t   sa_mask;
    int        sa_flags;
    void     (*sa_restorer)(void);　→ 廃止予定で使用すべきではない。
};

sigset_t 型のオブジェクトは、関数 sigaddset(), sigdelset(), sigismember() や後述の glibc の追加関数 (sigisemptyset(), sigandset(), sigorset()) に渡す前に、 sigemptyset() か sigfillset() を呼び出して初期化しなければならない。
初期化しなかった場合の結果は未定義である。

※アーキテクチャによっては共用体 (union) が用いられている場合、 sa_handler と sa_sigaction の両方を同時に割り当てることはできない。

sa_handler
signum に対応する動作を指定するもので、 デフォルトの動作を行う SIG_DFL 、そのシグナルを無視する SIG_IGN 、シグナルハンドラ関数へのポインタが設定可能。
シグナルハンドラ関数の引き数は一つであり、シグナル番号が引き数として渡される。
sa_flags に SA_SIGINFO(下のsa_flagsの項で説明) が指定された場合、 ( sa_handler ではなく) sa_sigaction により signum に対応するシグナルハンドル関数が指定される。
指定される関数は、最初の引数としてシグナル番号を、 二番目の引数として siginfo_t へのポインタを、三番目の引数として (void * にキャストした) ucontext_t へのポインタを受けとる。

void  sig_handler ( intsignum , siginfo_t * info, void * context)
 { 
   ( void )context; 
   ( void )情報; 
   ( void )signum; 
   printf ( "\nシグナル ハンドラー関数が %d と呼ばれました\n"、signum); 
int main ( void ) { struct sigaction sa ; 

sigemptyset(&sa.sa_mask);    def
sa.sa_flags = SA_RESTART | SA_SIGINFO;    def
１．sa.sa_sigaction = sig_handler;    ここが他の２つとちがう
（２．sa.sa_handler = SIG_DFL; ）
（３．sa.sa_handler = SIG_IGN; ）
sigaction(SIGINT, &sa, NULL ); while ( 1 )      
sleep( 1 ); リターン( 0 ); }


sa_mask
シグナルハンドラ実行中に禁止 (block) するシグナルのマスクを表す。
さらに、 SA_NODEFER (下のsa_flagsの項で説明) フラグが指定されていない場合は、ハンドラを起動するきっかけとなる シグナルにも sa_mask が適用される。
シグナルはシグナルハンドラの処理中に他のシグナルのシグナルハンドラを呼び出すことができるので、これが問題となることがある。
sa_mask要素は、sigaction関数の第一引数で与えられたシグナルのシグナルハンドラ実行中に無視(block)するシグナルのマスクを表す。
これが設定できるのはSIG_IGN、SIG_DEL以外のシグナルハンドラ。
例えばSIGINTで呼び出されたシグナルハンドラ処理中に、新たにSIGINTが到着した場合、新しく到着したSIGINTを無視する。これはデフォルト。
sa_maskはひとつが一種類のシグナルを扱うboolen型のフラグの集合として実装されており、このフラグセットの操作は次の4つの関数を用いる。

int sigemptyset(sigset_t *set)
    /* setの全フラグをセット */

int sigfillset(sigset_t *set)
     /* setの全フラグをリセット */

int sigaddset(sigset_t *set, int signum)
     /* signumで指定したフラグを個別にセット */

int sigdelset(sigset_t *set, int signum)
     /* signumで指定したフラグを個別にリセット */

sa_flags
sa_flagsはシグナル・ハンドラの動作を変更するためのフラグの集合を指定する。 sa_flags には、以下に示すフラグの (0個以上の) 論理和をとったものを指定する。

SA_SIGINFO
シグナルハンドラは一つではなく、三つの引き数を持つ。
この場合は sa_handler のかわりに sa_sigaction を設定しなければならない ( sa_sigaction フィールドは Linux 2.1.86 で追加)。
sigaction構造体のsa_flagsメンバがSA_SIGINFOになってたら、シグナルハンドラ関数の第２引数に使われる。

＜sigaction使用の流れ＞
①struct sigaction型の構造体変数saを宣言
struct sigaction sa;

②sigemptyset(&sa.sa_mask)でsaのシグナルマスクをクリアする
sigemptyset(&sa.sa_mask)

sigemptyset()を使うと、シグナルマスクをゼロクリア（マスクの設定は特になし）にすることができる。
引数は、struct sigaction型の構造体変数のメンバsa_maskのアドレスを渡す。
シグナルがセットのメンバであり正常に実行された場合、sigemptyset() は 1 を返す。
それ以外は 0 を返す。

③sa.sa_handlerにシグナルハンドラにしたい関数を割り当てる
sa.sa_handler = function;

シグナルハンドラにしたい関数をfunction()ならば、struct sigaction型の構造体saのメンバsa_handlerにfunctionを割り当てる。

④sa.sa_flagsにフラグを設定する
sa.sa_flags = 0;

フラグは、シグナルの詳細な情報が欲しい時などに、SA_SIGINFOを指定したりする。
とりあえず0でOK。


getpid
Macの基準範囲: 100~99999

引き続きクライアント側でシグナルを一方的に撃つと、そのシグナルがねじれる可能性があるので、usleep()適当にタムを与えなければならない。

bonus）Unicodeを渡す
writeは1バイトずつ出力をするのにどのように2～4バイトのUnicodeを出力してもらえるのか？
...Unicodeは先頭のビットで何バイトの文字かを知ることができます。writeは何バイトか知って、そのバイトだけシグナルを受け取るのでUnicode文字を出力してもらえる！

一部の Unicode 文字は負になるため、負の数値を処理する方法を理解する必要があります。バイナリの左端の値は、負の数を示す指標として機能します。

結論はexit()関数とmain()関数内でのint型を返すreturn文は同等である。したがって好きな方を使えば良い。どちらを使うにしろ、プログラムの中ではどちらかに統一した方が好ましい

しかし、関数の呼び出し先でプログラムを正常終了させるにはexit()関数を使うことになるだろう。またexit()関数には、atexit()関数を使って終了時に呼び出される関数を登録することもできる。プログラム終了時に独自の終了処理を追加したい場合には、やはりexit()関数を使うことになる。
最後にもう一つ。exit()関数の引数にはEXIT_SUCCESSまたはEXIT_FAILUEREが使える。これは<stdlib.h>でマクロとして定義されている。

C言語の中で sa.sa_handler と sa.sa_flags のようなメンバーへのアクセスは、関数ポインタを渡す際にアンパサンド (&) を使用しない場合、コンパイラが自動的に関数ポインタに変換します。したがって、 sa.sa_handler = handler; と sa.sa_handler = &handler; のどちらも正しい構文です。

sa.sa_flags = SA_SIGINFO;
この設定は、struct sigaction オブジェクトがシグナルハンドラ関数を使用する場合、シグナルハンドラに追加の情報を提供するためのものです。追加の情報には、シグナルが発生した際のコンテキスト情報やシグナルの送信元プロセスに関する情報が含まれます。このオプションを使用することで、シグナルハンドラがより多くの情報を利用できます。
sa.sa_flags = 0; (または sa.sa_flags を設定しない)
この設定は、シグナルハンドラに追加の情報を提供せず、シグナルハンドラを簡潔に保つために使用されます。この場合、シグナルハンドラは通常、シグナルが発生したことを検出し、適切な処理を行うだけです。
どちらの設定が正しいかは、プログラムが必要とする情報に依存します。シグナルハンドラがシグナルに関連する追加の情報を必要とする場合、SA_SIGINFO フラグを使用することが適しています。一方、追加の情報が不要である場合、sa.sa_flags を 0 または未設定にすることができます。

SA_SIGINFO
シグナルハンドラは一つではなく、三つの引き数を持つ。
この場合は sa_handler のかわりに sa_sigaction を設定しなければならない 

例）
act.sa_handler = handler;
act.sa_flags = 0;もしくは何も書かない
->handler(int sig)

act.sa_sigaction = handler;
act.sa_flags = SA_SIGINFO;
->handler(int sig, siginfo_t *siginfo, void *ucontext) 引数が３つになる




static volatile sig_atomic_t	g_client_pid;
if (siginfo->si_pid != 0)
	{
		g_client_pid = siginfo->si_pid;
		kill(siginfo->si_pid, SIGUSR1);
	}
	else
		kill(g_client_pid, SIGUSR1);

解説してください

siginfo->si_pid != 0: シグナルが送信元プロセスの PID に関する情報を持っている場合
siginfo->si_pid は、シグナルを送信したプロセスの PID を表します。
条件文は、si_pid が 0 ではない場合（つまり、シグナルが送信元のプロセスに関する情報を持っている場合）に真となります。
真の場合、以下の処理が実行されます：
g_client_pid は、siginfo->si_pid に設定され、最後にシグナルを送信したプロセスの PID が記録されます。
その後、siginfo->si_pid に対して SIGUSR1 シグナルが送信されます。これにより、送信元プロセスに応答が送信されます。
siginfo->si_pid == 0: シグナルが送信元プロセスの PID に関する情報を持っていない場合
si_pid が 0 の場合、シグナルが送信元のプロセスに関する情報を持っていないことを示します。
条件文は、si_pid が 0 の場合に真となります。
真の場合、以下の処理が実行されます：
g_client_pid は以前に覚えておいた送信先の PID です。この値は siginfo->si_pid が持っていた情報ではなく、以前に通信していた相手の PID です。
g_client_pid に SIGUSR1 シグナルが送信されます。これにより、以前の相手に応答が送信されます。



usleep 関数は、マイクロ秒単位で一定の時間（スリープ）をプログラムに挿入するために使用されます。この時間のスリープは、プログラムの実行を一時停止させるために用います。この場合、400マイクロ秒（0.4ミリ秒）のスリープが挿入されています。
その目的は「lag」（遅延または遅れ）を回避することです。コンテキストによっては、シグナルを送信している間に発生する可能性がある遅延を最小限に抑えるために、一時停止を挿入することが有用である場合があります。遅延があると、シグナルの送信や受信がタイムリーに行われない可能性があり、通信の信頼性に影響を与えることがあります。
このような状況では、一貫性のある通信やタイミングが重要であるため、特定のタイムアウトまたは遅延を持たせて通信を安定させるために usleep などの遅延関数を使用することが一般的です。

"si_pid"（siginfo 構造体のメンバー）がサーバーから送信されるはずなのに、時折0になる現象は、いくつかの要因によるものです。以下に、その理由と可能性のある解決策を説明します。
シグナルが競合している: 他のプロセスからの競合するシグナルがプログラムに送信され、"si_pid" が 0 になる可能性があります。シグナルはプロセス間で競合することがあり、プログラムが誤って競合シグナルを処理してしまうことがあります。この問題は、シグナルハンドリングを改善することで解決できるかもしれません。
競合を避けるための排他制御: シグナルを送信および処理する際に、競合を避けるための適切な排他制御を実装できます。例えば、プロセスがシグナルを送信する前に特定のフラグを設定し、シグナルハンドラでそのフラグを確認することで、競合を回避できる場合があります。
シグナルハンドリングの複雑さ: シグナルハンドリングの複雑さが原因で、"si_pid" が正しく設定されないことがあります。この場合、シグナルハンドリングコードを簡略化し、特に競合の可能性がある部分を注意深く見直すことが役立つことがあります。
プラットフォーム固有の問題: 一部のプラットフォームでは、シグナルの動作が異なることがあり、"si_pid" が 0 になることがあるかもしれません。プラットフォームごとにシグナルハンドリングの違いがあるため、特定のプラットフォームに固有の問題として考えることも重要です。
この問題を解決するためには、シグナルハンドリングコードを厳密に確認し、競合の可能性を最小限に抑え、プログラムの複雑さを減らすことが大切です。場合によっては、デバッグやトレースツールを使用してシグナルハンドリングの問題を特定するのも役立つかもしれません。

volatile 修飾型オブジェクトは、処理系が関与しない方法で変更されたり、その他の未知の副作用を持つ可能性がある。たとえば、非同期シグナル処理が原因で、コンパイラが認識しない方法で、オブジェクトが変更されることがある。volatile 型修飾子をつけないと、意図せぬ最適化が行われることもある。これらの最適化は競合状態の原因になることがある。プログラマが競合状態を避けるコードを書いても、コンパイラがプログラマのデータモデルを認識せずコンパイル時にコードを変更して競合状態を招く可能性があるからである。

volatile を宣言していないため、シグナルハンドラでの変数への割り当てにもかかわらず、main() での interrupted からの読み取りがコンパイラによる最適化で取り除かれループが終了しなくなる。たとえば、最適化のための -O フラグを使用して GCC でコンパイルすると、プログラムは SIGINT を受け取っても終了できない。

volatile 修飾子を使用しないと、コードの非同期部分に競合状態が発生する可能性がある。これにより、予期せぬ値が格納され、データの完全性が侵害される可能性がある。

volatile 修飾子は、 コンパイラーの制御または検出以外の方法 (システム・クロックや別のプログラムによって更新される変数など) で、値を変更できる データ・オブジェクトを宣言します。これにより、オブジェクトの値をレジスターに保管して、変更される可能性があるメモリーからではなくレジスターから再読み取りすることで、 オブジェクトを参照するコードをコンパイラーが最適化することがなくなります。
c言語では、シグナル処理関数は、変数が volatile として宣言されていれば、型 sig_atomic_t の変数に値を保管できます。これは、シグナル処理関数が静的ストレージ期間を使用した変数にアクセスできないという規則の例外です。

UNIXの仕様を定義しているPOSIXの2008の文章
先のPOSIXの文章ではsig_atomic_tが規定されていて、シグナルハンドラ内ではsig_atomic_t型の変数しか外と共有してはいけないと規定している。なんだかふわふわした表現だが、要は、1マシン命令でload,storeできる単位の型のグローバル変数(類)でしかシグナルハンドラの外と直接やり取りできない。

シグナルハンドラー関数の中で、グローバル変数として定義した構造体のメンバに代入をすることはできますか
...シグナルハンドラー関数の中でグローバル変数へのアクセスは、一般的には安全ではありません。シグナルハンドラー関数は非同期的に実行され、その間にプログラムの他の部分で同じ変数にアクセスしている可能性があるため、競合状態（race condition）が発生することがあります。
競合状態を避けるために、シグナルハンドラー関数内でグローバル変数へのアクセスを行う場合、適切な同期手法を使用する必要があります。
さらに、シグナルハンドラー関数内で行うべき操作は、できる限り簡潔で、時間のかかる処理やブロッキング操作を避けるべきです。シグナルは通常、非同期イベントをハンドリングするために使用され、処理が遅延されることが好ましくない場合があります。
グローバル変数をシグナルハンドラー関数内で使用する場合、競合状態に対処し、処理を簡潔に保つように注意してください。また、シグナルハンドラー関数の中での安全な操作に関しては、システムやプログラミング言語の仕様に従うことが重要です。

構造体の代入やmemcpy()なんかもアトミックに行えない典型的な処理となる
アトミックに行えない典型的な処理には、以下のようなものがあります：
読み込みと書き込みの競合（Read-Modify-Write Conflicts）: 複数のプロセスやスレッドが同一のメモリ位置に対して読み込み（load）と書き込み（store）を同時に行う場合、競合が発生し、正確なデータの保持が難しくなります。例えば、変数の値をインクリメントする操作（x = x + 1）が競合状態を引き起こす可能性があります。
非同期イベントハンドリング: イベントハンドリング処理中に、新しいイベントが発生すると、その新しいイベントと既存のイベントハンドリング処理が競合する可能性があります。たとえば、シグナルハンドラーが実行中に新しいシグナルが到着すると競合が発生します。
複数ステップから成る操作: 複数のステップから成る操作（トランザクションやプロセス）において、途中のステップが中断された場合、競合が発生し、システムが一貫性を維持できなくなります。このような場合、トランザクション管理やリカバリメカニズムが必要です。
これらの典型的な処理では、アトミック性（操作が不可分に実行されること）を確保することが難しいため、競合が発生しやすくなります。競合を適切に管理するためには、排他制御、トランザクション管理、イベントハンドリング、およびアクセス制御の適切な手法やプリミティブを使用する必要があります。
この規定を無視してコードを組むと、構造体のメンバaは更新されているのにメンバbはまだ更新されていない、なんてタイミングでシグナルハンドルされることも起こりうるわけで、おかしな値を読み書きする現象につながる。
ちなみにglibcではposix/bits/types.hでsig_atomic_tの型を定義しているが、結局ただのintであり、SIG_ATOMIC_MINは(-2147483647-1)、SIG_ATOMIC_MAXは2147483647になっている。(stdlib/stdint.h)

シグナルハンドラで共有オブジェクトにアクセスまたは変更すると、競合状態が発生し、データが矛盾した状態のままになる可能性がある。このルールの例外として、ロックフリーの不可分オブジェクトまたは volatile sig_atomic_t 型変数への読み書きは行ってもよい。

sig_atomic_t
アトミックにアクセスできる（他の処理が割り込むことができない）オブジェクトが持つ型。何らかの整数型である。volatile で修飾されているかもしれない。
格納できる値の範囲は、SIG_ATOMIC_MIN と SIG_ATOMIC_MAX で定義されている。
シグナルハンドラから安全にアクセスできるオブジェクトの型です。
シグナルハンドラが呼び出されるとき、通常の関数とは異なる制約があります。特に、シグナルハンドラが割り込みを受ける可能性があり、その結果、複数のスレッドやシグナルハンドラが同時に同じオブジェクトにアクセスする可能性があります。sig_atomic_t型の変数は、このような同時アクセスが安全に行われることを保証します。

結論から言うと、シグナルハンドラ内で安全に（未定義の動作にならずに）行える処理は以下に限られます。
非同期シグナル安全（async-signal-safe）な関数の呼び出し
volatile sig_atomic_t型変数の読み書き
シグナルハンドラ内の自動変数の読み書き

POSIX 2013 より前の POSIX 規格では、シグナルハンドラ内で出来ることはかなり制限されてゐました。出来ることはせいぜい volatile な sig_atomic_t 型の静的記憶域期間変数に値を代入することによってフラグを立てる程度でした。

sigemptyset 関数を使用して、初期状態でセット内に含まれるすべてのシグナルを削除し、空のセットを作成します。

sigaddset(&act.sa_mask, SIGUSR1); および sigaddset(&act.sa_mask, SIGUSR2);: これらの行は、シグナルセット act.sa_mask に SIGUSR1 と SIGUSR2 シグナルを追加します。つまり、シグナルハンドラー関数が実行されるときに SIGUSR1 と SIGUSR2 シグナルがブロックされます。これにより、この関数が実行されている間、同じプロセスによってこれらのシグナルが送信されても、そのシグナルが保留状態になり、処理されません。

g_list.pid が volatile sig_atomic_t 型ではないこと自体は問題ありません。volatile sig_atomic_t 型は通常、シグナルハンドラー内でアトミックな操作を必要とするフラグ変数に使用されますが、特定の型を持つ変数を使用することは一般的です。pid は通常の整数型であり、シグナルハンドラー内で参照されている場合でも、型として pid_t または int を使用するのが一般的です。

重要なのは、シグナルハンドラー内でグローバル変数にアクセスする場合、アクセスが競合しないように注意することです。競合状態が発生しないように確実にするために、volatile や sig_atomic_t を使用することはアプリケーションの信頼性を向上させるために役立つ場合がありますが、これは型としての選択ではなく、競合状態を避けるための適切な手法の一部です。

したがって、g_list.pid を pid_t または int のまま使用することは問題ありません。ただし、シグナルハンドラー内での変数へのアクセスを慎重に管理し、競合状態を避けるようにしてください。適切な同期手法を使用してデータ競合を防ぐことが重要です。