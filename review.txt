 たまにサーバー側が停止した際に、clientが待機状態になりました。client側も終了させても良いかもしれません。
 ...課題に使用できる関数の制限などから、対応が難しい

\nがnと出るのはshellの正常な挙動で$' 'で囲まないと改行として出力されないみたいです

この課題の制限により送信に失敗した時の対応が難しい

シグナルのでフラグをつけたり、killする場面に応じて同じシグナルでもマクロを定義していたりととても可読性のあるコードで感動しました。 また、複数clientに対応できないか試行錯誤されたお話も聞けて、結局この条件では不可能である（legacy signalだから、送り相手がだけか保持していないので、複数clientだと同時に送られた時同じビット列として扱われると結論づけられていてとても勉強になりました。

標準関数getpidは必ず成功するため(errorが起きることがなく、失敗の戻り値を返すことがない)、getpidについてはerror処理は不要。

type qualifier(型修飾子)の1つ「volatile」は、compilerが最適化するのを防ぐ。

(1) シグナルハンドラの処理中に来たシグナルを保留しておくためにシグナルマスクを設定する。 
(2) serverのシグナルハンドラの処理中にclientが追加でシグナルを送らないようにするため、1ビットごとにserverからacknowledgementを送信する。 
(3) この時, client側pauseしてからserverが送信するよう, server側で適当に時間調整する。 
(4) client**以外**からのシグナル送信を除外するため、siginfo_t構造体の情報を利用する。

[1] pidのvalidationが行われていなかったので、123a、オーバフローした値などの入力を受け付けていました。 
[2] シグナルハンドラ内でvolatile sig_atomic_tでない静的記憶期間を持つ変数へのアクセスが行われていました。
[5] signal関数は実行環境によって挙動が異なる場合があるので、sigactionを使うとより良かったと思います。

サーバーがプロセスIDを取得、標準出力に表示。 ビット演算とシフト演算を使用。 digit_of_bitstringは何番目かを表している シフト演算（＜＜）で道具を用意している。ビット演算（＆）で調べたい桁の情報を得ている。 ビット列の桁の値に応じて、キルするシグナルを変更している。SIGUSR1が1,SIGUSRI2が0を表している。 killすることでサーバーに送信をしている。 ＆が比較の両方が１とき１を返す。 usleepで80ms待機している。 |両方が０のとき０を返す。 サーバー側では元々０があるので、１を立てるかのみを判断する為｜を使用している。 8bitが揃ったタイミングで出力し。bitstrを初期化し再度待機する。 sigactionが受信待ちをしている。 killで信号をサーバーからクライアントに送信する。クライアント側ではサーバー側で選択したシグナルを受け取り、シグナルを受信したというメッセージを受け取ったsignal毎に標準出力に出力している。

cliant からバッククオートを含んだ文字列を入力すると変な感じになりました。B2Bを確認して、シェルスクリプトを呼び出す際に、コマンド部分を　` 　　` で括っているからだと理解することが出来ました（バッククオートにエスケープシーケンスが必要な理由） sever をまずgetpid 関数でpidを取得する。 signal を受け取れる状態を用意し、pause()で待機 シグナルは、SIGUSR1と2があるが、今回はcharデータのビットが0 か 1 かという情報に代替している。 char は1byteなので、八度シグナルをビット演算して繰り上がらせてやるようにすると、送られてきたchar の文字に復元することが出来る。 演算が終わった時、g_info_char を0に初期化しているが、ずらして足していくだけのビット演算ならそうしなくてもいいのでは？試しに消したが問題なかった。ただ、g_info.char のもつスタック領域でのメモリが1byteで、それを左？か右？かに大きくはみ出している可能性もありそう。0にした方が安全層ではあるが、折角ビット演算するなら工夫によっては大きく早くなりそう。 g_info.char >> 8 とかかな。右ずらし

// g_list.pid,g_list.flagの２つをグローバルで宣言する必要があるのは、ハンドラー関数の引数に渡せないから
// また、ハンドラー関数内だけで使うわけでもないため、関数内変数宣言という手段も使えないから
// g_list.pidは-1が帰ってくる可能性もあるため、pid_tではなくint